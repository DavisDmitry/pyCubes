{"config":{"lang":["en","ru"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"pyCubes <p> Documentation |  Examples |  Protocol Specification </p> <p>pyCubes is a library for creating servers and clients for Minecraft Java Edition.</p> <p>\u2757 0.x versions are not stable. The library API is subject to change.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyCubes\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Serializers for some Data types</li> <li>Connection</li> <li>Low level server</li> <li>NBT module (wrapper over the nbtlib)</li> <li><code>generate_uuid</code> utility (generates UUID by player_name for using in offline mode)</li> <li>AnyIO support (an asynchronous networking and concurrency library)</li> </ul>"},{"location":"#todo","title":"TODO","text":"<ul> <li> Serializers for Data types</li> <li> Network packets</li> <li> Implement compression</li> <li> High level server application with event driven API</li> <li> High level client application with event driven API</li> <li> High level proxy application with event driven API</li> <li> Chat API (chat messages constructor)</li> <li> Commands API</li> <li> Add API Reference to docs</li> </ul>"},{"location":"dev/","title":"Development","text":""},{"location":"dev/#scripts","title":"Scripts","text":"<p>Run formatting:</p> <pre><code>pdm format\n</code></pre> <p>Run linters:</p> <pre><code>pdm lint\n</code></pre> <p>Run tests:</p> <pre><code>pdm test\n</code></pre>"},{"location":"dev/#working-with-documentation","title":"Working with documentation","text":"<p>First you need to install requirments:</p> <pre><code>pdm install -d -G docs\n</code></pre> <p>Run the development server:</p> <pre><code>pdm docs-serve\n</code></pre> <p>Build (render) the docs:</p> <pre><code>pdm docs-build\n</code></pre> <p>Build and deploy the documentation to github pages:</p> <pre><code>pdm docs-deploy\n</code></pre>"},{"location":"examples/client/","title":"Client","text":"examples/client.py<pre><code>import enum\nimport io\nimport uuid\nfrom typing import Any, Callable, Coroutine\n\nimport anyio\n\nfrom cubes import net\nfrom cubes.net import serializers\n\n_PROTOCOL = 766\n_HOST = \"127.0.0.1\"\n_PORT = 25565\n_PLAYER_NAME = \"IamSmesharik\"\n\n\nclass NotConnectedError(Exception):\n    pass\n\n\nclass AlreadyConnectedError(Exception):\n    pass\n\n\nclass UnsuitedConnectionStatusForOperationError(Exception):\n    pass\n\n\nclass DisconnectedByServerError(Exception):\n    pass\n\n\nclass InvalidPlayerNameFromServer(Exception):\n    pass\n\n\nclass UnexpectedPacketError(Exception):\n    pass\n\n\nclass ConnectionState(enum.IntEnum):\n    HANDSHAKE = 0\n    STATUS = 1\n    LOGIN = 2\n    TRANSFER = 3\n    CONFIGURATION = 4\n    PLAY = 5\n\n\nclass Client:\n    _conn: net.Connection | None\n    _state: ConnectionState | None\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        self._host, self._port = host, port\n        self._conn = None\n        self._state = None\n\n    @property\n    def connection(self) -&gt; net.Connection:\n        if self._conn is None:\n            raise NotConnectedError\n        return self._conn\n\n    @property\n    def state(self) -&gt; ConnectionState:\n        if self._state is None:\n            raise NotConnectedError\n        return self._state\n\n    async def connect(self) -&gt; None:\n        if self._conn is not None:\n            raise AlreadyConnectedError\n        stream = await anyio.connect_tcp(self._host, self._port)\n        self._conn = net.Connection(stream)\n        self._state = ConnectionState.HANDSHAKE\n\n    async def disconnect(self) -&gt; None:\n        if self._conn:\n            await self._conn.close()\n        self._state = None\n\n    async def login(self, player_name: str) -&gt; uuid.UUID:\n        if self._state != ConnectionState.HANDSHAKE:\n            raise UnsuitedConnectionStatusForOperationError(self._state)\n\n        handshake = io.BytesIO()\n        serializers.VarIntSerializer(0x00).to_buffer(handshake)\n        serializers.VarIntSerializer(_PROTOCOL).to_buffer(handshake)\n        serializers.StringSerializer(self.connection.remote_address[0])\n        serializers.UnsignedShortSerializer(self.connection.remote_address[1])\n        serializers.VarIntSerializer(ConnectionState.LOGIN)\n\n        login_start = io.BytesIO()\n        serializers.VarIntSerializer(0x00).to_buffer(login_start)\n        serializers.StringSerializer(player_name).to_buffer(login_start)\n\n        await self.connection.send(handshake, login_start)\n\n        self._state = ConnectionState.LOGIN\n\n        response = await self.connection.receive()\n        packet_id = serializers.VarIntSerializer.from_buffer(response)\n        match packet_id:\n            case 0x00:\n                raise DisconnectedByServerError(\n                    serializers.StringSerializer.from_buffer(response)\n                )\n            case 0x02:\n                uuid_ = serializers.UUIDSerializer.from_buffer(response)\n                player_name_from_server = serializers.StringSerializer.from_buffer(\n                    response\n                )\n                if player_name != player_name_from_server:\n                    raise InvalidPlayerNameFromServer(player_name_from_server)\n                self._state = ConnectionState.CONFIGURATION\n                return uuid_\n            case _:\n                raise UnexpectedPacketError(hex(packet_id))\n\n    async def run(\n        self,\n        handler: Callable[[net.Connection, io.BytesIO], Coroutine[Any, Any, None]],\n        packet_receive_timeout: float = 20,\n    ) -&gt; None:\n        while True:\n            with anyio.fail_after(packet_receive_timeout):\n                packet = await self.connection.receive()\n            await handler(self.connection, packet)\n\n    async def __aenter__(self) -&gt; \"Client\":\n        await self.connect()\n        return self\n\n    async def __aexit__(self):\n        await self.disconnect()\n\n\nasync def process_packet(conn: net.Connection, packet: io.BytesIO): ...\n\n\nasync def main():\n    async with Client(_HOST, _PORT) as client:\n        await client.login(_PLAYER_NAME)\n        await client.run(process_packet)\n</code></pre>"},{"location":"examples/server/","title":"Server","text":"examples/server.py<pre><code>import enum\nimport io\nimport json\nimport logging\nimport signal\n\nimport anyio\nimport anyio.abc\n\nfrom cubes import net\nfrom cubes.net import serializers\n\n_VERSION = \"1.20.5-1.20.6\"\n_PROTOCOL = 766\n_SERVER_DESCRIPTION = \"Example server\"\n\n\nclass ConnectionState(enum.IntEnum):\n    HANDSHAKE = 0\n    STATUS = 1\n    LOGIN = 2\n    TRANSFER = 3\n    CONFIGURATION = 4\n    PLAY = 5\n\n\nCONNECTION_STATES: dict[net.Connection, ConnectionState] = {}\n\n\nasync def process_handshake(conn: net.Connection, packet: io.BytesIO):\n    protocol = serializers.VarIntSerializer.from_buffer(packet)\n    serializers.StringSerializer.from_buffer(packet)  # host\n    serializers.UnsignedShortSerializer.from_buffer(packet)  # port\n    CONNECTION_STATES[conn] = intention = ConnectionState(\n        serializers.VarIntSerializer.from_buffer(packet)\n    )\n    if (\n        intention in (ConnectionState.LOGIN, ConnectionState.TRANSFER)\n        and protocol != _PROTOCOL\n    ):\n        disconnect_packet = io.BytesIO()\n        serializers.VarIntSerializer(0).to_buffer(disconnect_packet)\n        serializers.StringSerializer(\n            json.dumps(\n                {\n                    \"translate\": \"disconnect.genericReason\",\n                    \"with\": [{\"text\": f'Unsupported protocol version \"{protocol}\".'}],\n                }\n            )\n        ).to_buffer(disconnect_packet)\n        await conn.send(disconnect_packet)\n        await conn.close()\n\n\nasync def process_legacy_ping(conn: net.Connection):\n    await conn.close()\n\n\nasync def process_status(conn: net.Connection):\n    response = io.BytesIO()\n    serializers.VarIntSerializer(0).to_buffer(response)\n    serializers.StringSerializer(\n        json.dumps(\n            {\n                \"version\": {\"name\": _VERSION, \"protocol\": _PROTOCOL},\n                \"players\": {\"max\": 0, \"online\": 0},\n                \"description\": {\"text\": _SERVER_DESCRIPTION},\n            }\n        )\n    ).to_buffer(response)\n    await conn.send(response)\n\n\nasync def process_status_ping(conn: net.Connection, packet: io.BytesIO):\n    packet.seek(0)\n    await conn.send(packet)\n    await conn.close()\n\n\nasync def process_packet(conn: net.Connection, packet: io.BytesIO):\n    state = CONNECTION_STATES[conn]\n    packet_id = serializers.VarIntSerializer.from_buffer(packet)\n    match (state, packet_id):\n        case (ConnectionState.HANDSHAKE, 0x00):\n            await process_handshake(conn, packet)\n        case (ConnectionState.HANDSHAKE, 0xFE):\n            await process_legacy_ping(conn)\n        case (ConnectionState.STATUS, 0x00):\n            await process_status(conn)\n        case (ConnectionState.STATUS, 0x01):\n            await process_status_ping(conn, packet)\n        case _:\n            pass\n\n\nasync def process_new_connection(conn: net.Connection):\n    logging.info('\"%s:%i\" connected to server.', *conn.remote_address)\n    CONNECTION_STATES[conn] = ConnectionState.HANDSHAKE\n\n\nasync def process_packet_receive_timeout(conn: net.Connection):\n    if CONNECTION_STATES[conn] == ConnectionState.LOGIN:\n        packet = io.BytesIO()\n        serializers.VarIntSerializer(0x00).to_buffer(packet)\n        serializers.StringSerializer(\n            json.dumps({\"translate\": \"disconnect.timeout\"})\n        ).to_buffer(packet)\n        await conn.send(packet)\n    await conn.close()\n\n\nasync def process_close_connection(conn: net.Connection, reason: Exception | None):\n    logging.info(\n        '\"%s:%i\" disconnected from server. Reason: %s.',\n        *conn.remote_address,\n        repr(reason),\n    )\n    del CONNECTION_STATES[conn]\n\n\nasync def sygnal_handler(scope: anyio.CancelScope):\n    with anyio.open_signal_receiver(signal.SIGINT, signal.SIGTERM) as signals:\n        async for _ in signals:\n            scope.cancel()\n\n\nasync def main():\n    server = net.Server(\n        process_new_connection,\n        process_packet_receive_timeout,\n        process_packet,\n        process_close_connection,\n        packet_receive_timeout=5,\n    )\n    async with anyio.create_task_group() as task_group:\n        task_group.start_soon(sygnal_handler, task_group.cancel_scope)\n        task_group.start_soon(server.run, \"127.0.0.1\", 25560)\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=\"DEBUG\")\n    # you shoud use anyio to run the server\n    # you can use trio or asyncio as backend\n    anyio.run(main, backend=\"trio\")\n</code></pre>"},{"location":"migrations/0_2/","title":"0.1 -> 0.2","text":""},{"location":"migrations/0_2/#01-02","title":"0.1 -&gt; 0.2","text":""},{"location":"migrations/0_2/#application","title":"Application","text":"<p>Host and port to run are now passed in the <code>Application.run</code> method</p> 0.10.2 <pre><code>import cubes\n\napp = cubes.Application('127.0.0.1', 25565)\napp.run()\n</code></pre> <pre><code>import cubes\n\napp = cubes.Application()\napp.run('127.0.0.1', 25565)\n</code></pre> <p>Now <code>packet_id</code> is passed to the packet handlers as the first arguments</p> 0.10.2 <pre><code>import cubes\n\nasync def handler(packet: cubes.ReadBuffer):\n    pass\n</code></pre> <pre><code>import cubes\n\nasync def handler(packet_id: int, packet: cubes.ReadBuffer):\n    pass\n</code></pre> <p>The value returned by the handler is now ignored. You must send all packets yourself</p> 0.10.2 <pre><code>import cubes\n\nasync def handler(packet: cubes.ReadBuffer) -&gt; Optional[cubes.WriteBuffer]:\n    \"\"\"Process Status Ping.\"\"\"\n    return cubes.WriteBuffer().pack_varint(0x01).write(packet.read(8))\n</code></pre> <pre><code>import cubes\n\nasync def handler(packet_id: int, packet: cubes.ReadBuffer) -&gt; None:\n    \"\"\"Process Status Ping.\"\"\"\n    await packet.connection.send(\n        cubes.WriteBuffer().pack_varint(0x01).write(packet_read(8)\n    )\n</code></pre>"},{"location":"migrations/0_2/#readbuffer","title":"ReadBuffer","text":"<p>Now the <code>connection</code> argument is required for initialization</p> 0.10.2 <pre><code>import cubes\n\n...\n\nbuff = cubes.ReadBuffer()\n</code></pre> <pre><code>import cubes\nimport cubes.abc\n\n...\n\nconn: cubes.abc.AbstractConnection\nbuff = cubes.ReadBuffer(conn)\n</code></pre> <p>The same argument appeared for the <code>from_reader</code> method</p> 0.10.2 <pre><code>import asyncio\nimport cubes\n\n...\n\nreader: asyncio.StreamReader\nbuff = await cubes.ReadBuffer.from_reader(reader)\n</code></pre> <pre><code>import asyncio\nimport cubes\nimport cubes.abc\n\n...\n\nconn: cubes.abc.AbstractConnection\nreader: asyncio.StreamReader\nbuff = await cubes.ReadBuffer.from_reader(conn, reader)\n</code></pre>"},{"location":"migrations/0_2/#connection","title":"Connection","text":"<p>The <code>\u0421onnection</code> class has been replaced with <code>PlayerConnection</code>.</p> <p>When initializing it, you must pass an <code>Application</code> instance</p> 0.10.2 <pre><code>import asyncio\nimport cubes\n\n...\n\nreader: asyncio.StreamReader\nwriter: asyncio.StreamWriter\nconn = cubes.Connection(reader, writer)\n</code></pre> <pre><code>import asyncio\nimport cubes\nimport cubes.abc\n\n...\n\nreader: asyncio.StreamReader\nwriter: asyncio.StreamWriter\napp: cubes.abc.Application\nconn = cubes.Connection(reader, writer, app)\n</code></pre> <p>An optional argument <code>reason</code> has been added to the<code>close</code> method and the <code>\u0421loseConnection</code> exception</p> PlayerConnectionCloseConnection <pre><code>import cubes\n\n...\n\nconn: cubes.PlayerConnection\nreason: str\nawait conn.close(reason)\n</code></pre> <pre><code>import cubes\n\n...\n\nreason: str\nraise cubes.CloseConnection(reason)\n</code></pre> <p>Removed <code>set_current</code> and <code>get_current</code> methods. Instead of <code>get_current</code>, use the instance from the <code>connection</code> property of <code>ReadBuffer</code></p> 0.10.2 <pre><code>import cubes\n\n...\n\nasync def handler(packet: cubes.ReadBuffer):\n    conn = cubes.Connection.get_current()\n</code></pre> <pre><code>import cubes\n\n...\n\nasync def handler(packet_id: int, packet: cubes.ReadBuffer):\n    conn = packet.connection\n</code></pre>"},{"location":"ru/","title":"\u0413\u043b\u0430\u0432\u043d\u0430\u044f","text":"pyCubes <p>\u0421\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0430</p> <p>pyCubes \u2014 \u044d\u0442\u043e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u0432 \u0438 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 Minecraft Java Edition.</p> <p>\u2757 0.x \u0432\u0435\u0440\u0441\u0438\u0438 \u043d\u0435 \u0441\u0442\u0430\u0431\u0438\u043b\u044c\u043d\u044b, API \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u043c\u043e\u0436\u0435\u0442 \u0438\u0437\u043c\u0435\u043d\u044f\u0442\u044c\u0441\u044f.</p>"},{"location":"ru/#_1","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430","text":"<pre><code>pip install pyCubes\n</code></pre>"},{"location":"ru/#_2","title":"\u041e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438","text":"<ul> <li>\u0421\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0430\u0442\u043e\u0440\u044b \u0434\u043b\u044f \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445</li> <li>\u041a\u043b\u0430\u0441\u0441 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f</li> <li>\u041d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u0441\u0435\u0440\u0432\u0435\u0440</li> <li>NBT \u043c\u043e\u0434\u0443\u043b\u044c (\u043e\u0431\u0451\u0440\u0442\u043a\u0430 \u043d\u0430\u0434 nbtlib)</li> <li><code>generate_uuid</code> \u0443\u0442\u0438\u043b\u0438\u0442\u0430 (\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 UUID \u043f\u043e \u043d\u0438\u043a\u0443 \u0438\u0433\u0440\u043e\u043a\u0430 \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 offline \u0440\u0435\u0436\u0438\u043c\u0435)</li> <li>\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 AnyIO (\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0441\u0435\u0442\u044c\u044e \u0438 \u043a\u043e\u043d\u043a\u0443\u0440\u0435\u043d\u0442\u043e\u0441\u0442\u0438)</li> </ul>"},{"location":"ru/#todo","title":"TODO","text":"<ul> <li> \u0421\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0430\u0442\u043e\u0440\u044b \u0434\u043b\u044f \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445</li> <li> \u0421\u0435\u0442\u0435\u0432\u044b\u0435 \u043f\u0430\u043a\u0435\u0442\u044b</li> <li> \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0436\u0430\u0442\u0438\u0435 \u043f\u0430\u043a\u0435\u0442\u043e\u0432</li> <li> \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 event driven API</li> <li> \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0441 event driven API</li> <li> \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043f\u0440\u043e\u043a\u0441\u0438 \u0441 event driven API</li> <li> Chat API (\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0447\u0430\u0442\u0430)</li> <li> Commands API</li> <li> \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 API \u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e</li> </ul>"},{"location":"ru/dev/","title":"\u0420\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430","text":""},{"location":"ru/dev/#c","title":"C\u043a\u0440\u0438\u043f\u0442\u044b","text":"<p>\u0417\u0430\u043f\u0443\u0441\u043a \u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f:</p> <pre><code>pdm format\n</code></pre> <p>\u0417\u0430\u043f\u0443\u0441\u043a \u043b\u0438\u043d\u0442\u0435\u0440\u043e\u0432:</p> <pre><code>pdm lint\n</code></pre> <p>\u0417\u0430\u043f\u0443\u0441\u043a \u0442\u0435\u0441\u0442\u043e\u0432:</p> <pre><code>pdm test\n</code></pre>"},{"location":"ru/dev/#_2","title":"\u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439","text":"<p>C\u043d\u0430\u0447\u0430\u043b\u0430 \u043d\u0443\u0436\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0443\u0442\u0438\u043b\u0438\u0442\u044b:</p> <pre><code>pdm install -d -G docs\n</code></pre> <p>\u0417\u0430\u043f\u0443\u0441\u043a dev-\u0441\u0435\u0440\u0432\u0435\u0440\u0430:</p> <pre><code>pdm docs-serve\n</code></pre> <p>\u0421\u0431\u043e\u0440\u043a\u0430 (\u0440\u0435\u043d\u0434\u0435\u0440) \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438:</p> <pre><code>pdm docs-build\n</code></pre> <p>\u0421\u0431\u043e\u0440\u043a\u0430 \u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043d\u0430 github pages:</p> <pre><code>pdm docs-deploy\n</code></pre>"},{"location":"ru/migrations/0_2/#application","title":"Application","text":"<p>\u0425\u043e\u0441\u0442 \u0438 \u043f\u043e\u0440\u0442 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u0442\u0435\u043f\u0435\u0440\u044c \u043f\u0435\u0440\u0435\u0434\u0430\u044e\u0442\u0441\u044f \u0432 \u043c\u0435\u0442\u043e\u0434\u0435 <code>Application.run</code></p> \u0411\u044b\u043b\u043eC\u0442\u0430\u043b\u043e <pre><code>import cubes\n\napp = cubes.Application('127.0.0.1', 25565)\napp.run()\n</code></pre> <pre><code>import cubes\n\napp = cubes.Application()\napp.run('127.0.0.1', 25565)\n</code></pre> <p>\u0412 \u0445\u0435\u043d\u0434\u043b\u0435\u0440\u044b \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0442\u0435\u043f\u0435\u0440\u044c \u043f\u0435\u0440\u0432\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043f\u0435\u0440\u0435\u0434\u0430\u0451\u0442\u0441\u044f <code>packet_id</code></p> \u0411\u044b\u043b\u043eC\u0442\u0430\u043b\u043e <pre><code>import cubes\n\nasync def handler(packet: cubes.ReadBuffer):\n    pass\n</code></pre> <pre><code>import cubes\n\nasync def handler(packet_id: int, packet: cubes.ReadBuffer):\n    pass\n</code></pre> <p>\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0445\u0435\u043d\u0434\u043b\u0435\u0440\u043e\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u0435\u0440\u044c \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442\u0441\u044f. \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0432\u0441\u0435 \u043f\u0430\u043a\u0435\u0442\u044b \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e</p> \u0411\u044b\u043b\u043e\u0421\u0442\u0430\u043b\u043e <pre><code>import cubes\n\nasync def handler(packet: cubes.ReadBuffer) -&gt; Optional[cubes.WriteBuffer]:\n    \"\"\"Process Status Ping.\"\"\"\n    return cubes.WriteBuffer().pack_varint(0x01).write(packet.read(8))\n</code></pre> <pre><code>import cubes\n\nasync def handler(packet_id: int, packet: cubes.ReadBuffer) -&gt; None:\n    \"\"\"Process Status Ping.\"\"\"\n    await packet.connection.send(\n        cubes.WriteBuffer().pack_varint(0x01).write(packet_read(8)\n    )\n</code></pre>"},{"location":"ru/migrations/0_2/#readbuffer","title":"ReadBuffer","text":"<p>\u0422\u0435\u043f\u0435\u0440\u044c \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 <code>connection</code></p> \u0411\u044b\u043b\u043e\u0421\u0442\u0430\u043b\u043e <pre><code>import cubes\n\n...\n\nbuff = cubes.ReadBuffer()\n</code></pre> <pre><code>import cubes\nimport cubes.abc\n\n...\n\nconn: cubes.abc.AbstractConnection\nbuff = cubes.ReadBuffer(conn)\n</code></pre> <p>\u0422\u0430\u043a\u043e\u0439 \u0436\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u043e\u044f\u0432\u0438\u043b\u0441\u044f \u0438 \u0443 \u043c\u0435\u0442\u043e\u0434\u0430 <code>from_reader</code></p> \u0411\u044b\u043b\u043e\u0421\u0442\u0430\u043b\u043e <pre><code>import asyncio\nimport cubes\n\n...\n\nreader: asyncio.StreamReader\nbuff = await cubes.ReadBuffer.from_reader(reader)\n</code></pre> <pre><code>import asyncio\nimport cubes\nimport cubes.abc\n\n...\n\nconn: cubes.abc.AbstractConnection\nreader: asyncio.StreamReader\nbuff = await cubes.ReadBuffer.from_reader(conn, reader)\n</code></pre>"},{"location":"ru/migrations/0_2/#connection","title":"Connection","text":"<p>\u041a\u043b\u0430\u0441\u0441 <code>\u0421onnection</code> \u0437\u0430\u043c\u0435\u043d\u0451\u043d \u043d\u0430 <code>PlayerConnection</code>.</p> <p>\u041f\u0440\u0438 \u0435\u0433\u043e \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u0438\u043d\u0441\u0442\u0430\u043d\u0441 <code>Application</code></p> \u0411\u044b\u043b\u043e\u0421\u0442\u0430\u043b\u043e <pre><code>import asyncio\nimport cubes\n\n...\n\nreader: asyncio.StreamReader\nwriter: asyncio.StreamWriter\nconn = cubes.Connection(reader, writer)\n</code></pre> <pre><code>import asyncio\nimport cubes\nimport cubes.abc\n\n...\n\nreader: asyncio.StreamReader\nwriter: asyncio.StreamWriter\napp: cubes.abc.Application\nconn = cubes.Connection(reader, writer, app)\n</code></pre> <p>\u0412 \u043c\u0435\u0442\u043e\u0434 <code>close</code> \u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 <code>\u0421loseConnection</code> \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d \u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 <code>reason</code></p> PlayerConnectionCloseConnection <pre><code>import cubes\n\n...\n\nconn: cubes.PlayerConnection\nreason: str\nawait conn.close(reason)\n</code></pre> <pre><code>import cubes\n\n...\n\nreason: str\nraise cubes.CloseConnection(reason)\n</code></pre> <p>\u0423\u0434\u0430\u043b\u0435\u043d\u044b \u043c\u0435\u0442\u043e\u0434\u044b <code>set_current</code> \u0438 <code>get_current</code>. \u0412\u043c\u0435\u0441\u0442\u043e <code>get_current</code> \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0438\u043d\u0441\u0442\u0430\u043d\u0441 \u0438\u0437 property <code>connection</code> \u0443 <code>ReadBuffer</code></p> \u0411\u044b\u043b\u043e\u0421\u0442\u0430\u043b\u043e <pre><code>import cubes\n\n...\n\nasync def handler(packet: cubes.ReadBuffer):\n    conn = cubes.Connection.get_current()\n</code></pre> <pre><code>import cubes\n\n...\n\nasync def handler(packet_id: int, packet: cubes.ReadBuffer):\n    conn = packet.connection\n</code></pre>"}]}