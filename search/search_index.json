{"config":{"indexing":"full","lang":["en","ru"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyCubes Protocol Specification pyCubes is a library for creating servers and clients for Minecraft Java Edition (1.14+). \u2757 0.x versions are not stable. The library API is subject to change. Installation pip install pyCubes Features Serializers for Data types (missing Chat, use String instead) Connection Low level server NBT module (wrapper over the nbtlib ) generate_uuid utility (generates UUID by player_name for using in offline mode) AnyIO support (an asynchronous networking and concurrency library) TODO Serializer for all packets Data types Packets descriptor Implement compression High level server application with event driven API High level client application with event driven API High level proxy application with event driven API Chat API (chat messages constructor) Commands API Add API Reference to docs","title":"Home"},{"location":"#installation","text":"pip install pyCubes","title":"Installation"},{"location":"#features","text":"Serializers for Data types (missing Chat, use String instead) Connection Low level server NBT module (wrapper over the nbtlib ) generate_uuid utility (generates UUID by player_name for using in offline mode) AnyIO support (an asynchronous networking and concurrency library)","title":"Features"},{"location":"#todo","text":"Serializer for all packets Data types Packets descriptor Implement compression High level server application with event driven API High level client application with event driven API High level proxy application with event driven API Chat API (chat messages constructor) Commands API Add API Reference to docs","title":"TODO"},{"location":"dev/","text":"Development Scripts Run formatting: make format Run linters: make lint Run tests: make test Working with documentation First you need to install requirments: poetry install -E docs Run the development server: make docs-serve Build (render) the docs: make docs-build Build and deploy the documentation to github pages: make docs-deploy","title":"Development"},{"location":"dev/#development","text":"","title":"Development"},{"location":"dev/#scripts","text":"Run formatting: make format Run linters: make lint Run tests: make test","title":"Scripts"},{"location":"dev/#working-with-documentation","text":"First you need to install requirments: poetry install -E docs Run the development server: make docs-serve Build (render) the docs: make docs-build Build and deploy the documentation to github pages: make docs-deploy","title":"Working with documentation"},{"location":"examples/client/","text":"examples/client.py import io import uuid from typing import Any , Callable , Coroutine import anyio from cubes import net from cubes.net import serializers _PROTOCOL = 756 _HOST = \"127.0.0.1\" _PORT = 25565 _PLAYER_NAME = \"_Smesharik_\" class NotConnectedError ( Exception ): pass class AlreadyConnectedError ( Exception ): pass class UnsuitedConnectionStatusForOperationError ( Exception ): pass class DisconnectedByServerError ( Exception ): pass class InvalidPlayerNameFromServer ( Exception ): pass class UnexpectedPacketError ( Exception ): pass class Client : _conn : net . Connection | None def __init__ ( self , host : str , port : int ) -> None : self . _host , self . _port = host , port self . _conn = None @property def connection ( self ) -> net . Connection : if self . _conn is None : raise NotConnectedError return self . _conn async def connect ( self ) -> None : if self . _conn is not None : raise AlreadyConnectedError stream = await anyio . connect_tcp ( self . _host , self . _port ) self . _conn = net . Connection ( stream ) async def disconnect ( self ) -> None : await self . _conn . close () async def login ( self , player_name : str ) -> uuid . UUID : if self . connection . status != net . ConnectionStatus . HANDSHAKE : raise UnsuitedConnectionStatusForOperationError ( self . connection . status ) handshake = io . BytesIO () serializers . VarIntSerializer ( 0x00 ) . to_buffer ( handshake ) serializers . VarIntSerializer ( _PROTOCOL ) . to_buffer ( handshake ) serializers . StringSerializer ( self . connection . remote_address [ 0 ]) serializers . UnsignedShortSerializer ( self . connection . remote_address [ 1 ]) serializers . VarIntSerializer ( net . ConnectionStatus . LOGIN ) login_start = io . BytesIO () serializers . VarIntSerializer ( 0x00 ) . to_buffer ( login_start ) serializers . StringSerializer ( player_name ) . to_buffer ( login_start ) await self . connection . send ( handshake , login_start ) self . connection . status = net . ConnectionStatus . LOGIN response = await self . connection . receive () packet_id = serializers . VarIntSerializer . from_buffer ( response ) match packet_id : case 0x00 : raise DisconnectedByServerError ( serializers . StringSerializer . from_buffer ( response ) ) case 0x02 : uuid_ = serializers . UUIDSerializer . from_buffer ( response ) player_name_from_server = serializers . StringSerializer . from_buffer ( response ) if player_name != player_name_from_server : raise InvalidPlayerNameFromServer ( player_name_from_server ) self . connection . status = net . ConnectionStatus . PLAY return uuid_ case _ : raise UnexpectedPacketError ( hex ( packet_id )) async def run ( self , handler : Callable [[ net . Connection , io . BytesIO ], Coroutine [ Any , Any , None ]], packet_receive_timeout : float = 20 , ) -> None : while True : with anyio . fail_after ( packet_receive_timeout ): packet = await self . connection . receive () await handler ( self . connection , packet ) async def __aenter__ ( self ) -> \"Client\" : await self . connect () return self async def __aexit__ ( self ): await self . disconnect () async def process_packet ( conn : net . Connection , packet : io . BytesIO ): ... async def main (): async with Client ( _HOST , _PORT ) as client : await client . login ( _PLAYER_NAME ) await client . run ( process_packet )","title":"Client"},{"location":"examples/server/","text":"examples/server.py import io import json import logging import signal import anyio import anyio.abc from cubes import net from cubes.net import serializers _VERSION = \"1.17.1\" _PROTOCOL = 756 _SERVER_DESCRIPTION = \"Example server\" async def process_handshake ( conn : net . Connection , packet : io . BytesIO ): protocol = serializers . VarIntSerializer . from_buffer ( packet ) serializers . StringSerializer . from_buffer ( packet ) # host serializers . UnsignedShortSerializer . from_buffer ( packet ) # port conn . status = intention = net . ConnectionStatus ( serializers . VarIntSerializer . from_buffer ( packet ) ) if intention == net . ConnectionStatus . LOGIN and protocol != _PROTOCOL : disconnect_packet = io . BytesIO () serializers . VarIntSerializer ( 0 ) . to_buffer ( disconnect_packet ) serializers . StringSerializer ( json . dumps ( { \"translate\" : \"disconnect.genericReason\" , \"with\" : [{ \"text\" : f 'Unsupported protocol version \" { protocol } \".' }], } ) ) . to_buffer ( disconnect_packet ) await conn . send ( disconnect_packet ) await conn . close () async def process_legacy_ping ( conn : net . Connection ): await conn . close () async def process_status ( conn : net . Connection ): response = io . BytesIO () serializers . VarIntSerializer ( 0 ) . to_buffer ( response ) serializers . StringSerializer ( json . dumps ( { \"version\" : { \"name\" : _VERSION , \"protocol\" : _PROTOCOL }, \"players\" : { \"max\" : 0 , \"online\" : 0 }, \"description\" : { \"text\" : _SERVER_DESCRIPTION }, } ) ) . to_buffer ( response ) await conn . send ( response ) async def process_status_ping ( conn : net . Connection , packet : io . BytesIO ): packet . seek ( 0 ) await conn . send ( packet ) await conn . close () async def process_packet ( conn : net . Connection , packet : io . BytesIO ): packet_id = serializers . VarIntSerializer . from_buffer ( packet ) match ( conn . status , packet_id ): case ( net . ConnectionStatus . HANDSHAKE , 0x00 ): await process_handshake ( conn , packet ) case ( net . ConnectionStatus . HANDSHAKE , 0xFE ): await process_legacy_ping ( conn ) case ( net . ConnectionStatus . STATUS , 0x00 ): await process_status ( conn ) case ( net . ConnectionStatus . STATUS , 0x01 ): await process_status_ping ( conn , packet ) case _ : pass async def process_new_connection ( conn : net . Connection ): logging . info ( '\" %s : %i \" connected to server.' , * conn . remote_address ) async def process_packet_receive_timeout ( conn : net . Connection ): if conn . status == net . ConnectionStatus . LOGIN : packet = io . BytesIO () serializers . VarIntSerializer ( 0x00 ) . to_buffer ( packet ) serializers . StringSerializer ( json . dumps ({ \"translate\" : \"disconnect.timeout\" }) ) . to_buffer ( packet ) await conn . send ( packet ) await conn . close () async def process_close_connection ( conn : net . Connection , reason : Exception | None ): logging . info ( '\" %s : %i \" disconnected from server. Reason: %s .' , * conn . remote_address , repr ( reason ), ) async def sygnal_handler ( scope : anyio . CancelScope ): with anyio . open_signal_receiver ( signal . SIGINT , signal . SIGTERM ) as signals : async for _ in signals : scope . cancel () async def main (): server = net . Server ( process_new_connection , process_packet_receive_timeout , process_packet , process_close_connection , packet_receive_timeout = 5 , ) async with anyio . create_task_group () as task_group : task_group . start_soon ( sygnal_handler , task_group . cancel_scope ) task_group . start_soon ( server . run , \"127.0.0.1\" , 25560 ) if __name__ == \"__main__\" : logging . basicConfig ( level = \"DEBUG\" ) # you shoud use anyio for run server # you can use trio or asyncio as backend anyio . run ( main , backend = \"trio\" )","title":"Server"},{"location":"migrations/0_2/","text":"0.1 -> 0.2 Application Host and port to run are now passed in the Application.run method 0.1 0.2 import cubes app = cubes . Application ( '127.0.0.1' , 25565 ) app . run () import cubes app = cubes . Application () app . run ( '127.0.0.1' , 25565 ) Now packet_id is passed to the packet handlers as the first arguments 0.1 0.2 import cubes async def handler ( packet : cubes . ReadBuffer ): pass import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ): pass The value returned by the handler is now ignored. You must send all packets yourself 0.1 0.2 import cubes async def handler ( packet : cubes . ReadBuffer ) -> Optional [ cubes . WriteBuffer ]: \"\"\"Process Status Ping.\"\"\" return cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet . read ( 8 )) import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ) -> None : \"\"\"Process Status Ping.\"\"\" await packet . connection . send ( cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet_read ( 8 ) ) ReadBuffer Now the connection argument is required for initialization 0.1 0.2 import cubes ... buff = cubes . ReadBuffer () import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection buff = cubes . ReadBuffer ( conn ) The same argument appeared for the from_reader method 0.1 0.2 import asyncio import cubes ... reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( reader ) import asyncio import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( conn , reader ) Connection The \u0421onnection class has been replaced with PlayerConnection . When initializing it, you must pass an Application instance 0.1 0.2 import asyncio import cubes ... reader : asyncio . StreamReader writer : asyncio . StreamWriter conn = cubes . Connection ( reader , writer ) import asyncio import cubes import cubes.abc ... reader : asyncio . StreamReader writer : asyncio . StreamWriter app : cubes . abc . Application conn = cubes . Connection ( reader , writer , app ) An optional argument reason has been added to the close method and the \u0421loseConnection exception PlayerConnection CloseConnection import cubes ... conn : cubes . PlayerConnection reason : str await conn . close ( reason ) import cubes ... reason : str raise cubes . CloseConnection ( reason ) Removed set_current and get_current methods. Instead of get_current , use the instance from the connection property of ReadBuffer 0.1 0.2 import cubes ... async def handler ( packet : cubes . ReadBuffer ): conn = cubes . Connection . get_current () import cubes ... async def handler ( packet_id : int , packet : cubes . ReadBuffer ): conn = packet . connection","title":"0.1 -> 0.2"},{"location":"migrations/0_2/#01-02","text":"","title":"0.1 -&gt; 0.2"},{"location":"migrations/0_2/#application","text":"Host and port to run are now passed in the Application.run method 0.1 0.2 import cubes app = cubes . Application ( '127.0.0.1' , 25565 ) app . run () import cubes app = cubes . Application () app . run ( '127.0.0.1' , 25565 ) Now packet_id is passed to the packet handlers as the first arguments 0.1 0.2 import cubes async def handler ( packet : cubes . ReadBuffer ): pass import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ): pass The value returned by the handler is now ignored. You must send all packets yourself 0.1 0.2 import cubes async def handler ( packet : cubes . ReadBuffer ) -> Optional [ cubes . WriteBuffer ]: \"\"\"Process Status Ping.\"\"\" return cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet . read ( 8 )) import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ) -> None : \"\"\"Process Status Ping.\"\"\" await packet . connection . send ( cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet_read ( 8 ) )","title":"Application"},{"location":"migrations/0_2/#readbuffer","text":"Now the connection argument is required for initialization 0.1 0.2 import cubes ... buff = cubes . ReadBuffer () import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection buff = cubes . ReadBuffer ( conn ) The same argument appeared for the from_reader method 0.1 0.2 import asyncio import cubes ... reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( reader ) import asyncio import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( conn , reader )","title":"ReadBuffer"},{"location":"migrations/0_2/#connection","text":"The \u0421onnection class has been replaced with PlayerConnection . When initializing it, you must pass an Application instance 0.1 0.2 import asyncio import cubes ... reader : asyncio . StreamReader writer : asyncio . StreamWriter conn = cubes . Connection ( reader , writer ) import asyncio import cubes import cubes.abc ... reader : asyncio . StreamReader writer : asyncio . StreamWriter app : cubes . abc . Application conn = cubes . Connection ( reader , writer , app ) An optional argument reason has been added to the close method and the \u0421loseConnection exception PlayerConnection CloseConnection import cubes ... conn : cubes . PlayerConnection reason : str await conn . close ( reason ) import cubes ... reason : str raise cubes . CloseConnection ( reason ) Removed set_current and get_current methods. Instead of get_current , use the instance from the connection property of ReadBuffer 0.1 0.2 import cubes ... async def handler ( packet : cubes . ReadBuffer ): conn = cubes . Connection . get_current () import cubes ... async def handler ( packet_id : int , packet : cubes . ReadBuffer ): conn = packet . connection","title":"Connection"},{"location":"ru/","text":"pyCubes \u0421\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0430 pyCubes \u2014 \u044d\u0442\u043e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u0432 \u0438 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 Minecraft Java Edition (1.14+). \u2757 0.x \u0432\u0435\u0440\u0441\u0438\u0438 \u043d\u0435 \u0441\u0442\u0430\u0431\u0438\u043b\u044c\u043d\u044b, API \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u043c\u043e\u0436\u0435\u0442 \u0438\u0437\u043c\u0435\u043d\u044f\u0442\u044c\u0441\u044f. \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 pip install pyCubes \u041e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0421\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0430\u0442\u043e\u0440\u044b \u0434\u043b\u044f \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445 (\u043a\u0440\u043e\u043c\u0435 Chat, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 String \u0432\u043c\u0435\u0441\u0442\u043e \u043d\u0435\u0433\u043e) \u041a\u043b\u0430\u0441\u0441 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u041d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u0441\u0435\u0440\u0432\u0435\u0440 NBT \u043c\u043e\u0434\u0443\u043b\u044c (\u043e\u0431\u0451\u0440\u0442\u043a\u0430 \u043d\u0430\u0434 nbtlib ) generate_uuid \u0443\u0442\u0438\u043b\u0438\u0442\u0430 (\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 UUID \u043f\u043e \u043d\u0438\u043a\u0443 \u0438\u0433\u0440\u043e\u043a\u0430 \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 offline \u0440\u0435\u0436\u0438\u043c\u0435) \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 AnyIO (\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0441\u0435\u0442\u044c\u044e \u0438 \u043a\u043e\u043d\u043a\u0443\u0440\u0435\u043d\u0442\u043e\u0441\u0442\u0438) TODO \u0421\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0430\u0442\u043e\u0440\u044b \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445 \u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0436\u0430\u0442\u0438\u0435 \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 event driven API \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0441 event driven API \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043f\u0440\u043e\u043a\u0441\u0438 \u0441 event driven API Chat API (\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0447\u0430\u0442\u0430) Commands API \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 API \u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e","title":"\u0413\u043b\u0430\u0432\u043d\u0430\u044f"},{"location":"ru/#_1","text":"pip install pyCubes","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430"},{"location":"ru/#_2","text":"\u0421\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0430\u0442\u043e\u0440\u044b \u0434\u043b\u044f \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445 (\u043a\u0440\u043e\u043c\u0435 Chat, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 String \u0432\u043c\u0435\u0441\u0442\u043e \u043d\u0435\u0433\u043e) \u041a\u043b\u0430\u0441\u0441 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u041d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u0441\u0435\u0440\u0432\u0435\u0440 NBT \u043c\u043e\u0434\u0443\u043b\u044c (\u043e\u0431\u0451\u0440\u0442\u043a\u0430 \u043d\u0430\u0434 nbtlib ) generate_uuid \u0443\u0442\u0438\u043b\u0438\u0442\u0430 (\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 UUID \u043f\u043e \u043d\u0438\u043a\u0443 \u0438\u0433\u0440\u043e\u043a\u0430 \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 offline \u0440\u0435\u0436\u0438\u043c\u0435) \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 AnyIO (\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0441\u0435\u0442\u044c\u044e \u0438 \u043a\u043e\u043d\u043a\u0443\u0440\u0435\u043d\u0442\u043e\u0441\u0442\u0438)","title":"\u041e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438"},{"location":"ru/#todo","text":"\u0421\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0430\u0442\u043e\u0440\u044b \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445 \u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0436\u0430\u0442\u0438\u0435 \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441 event driven API \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0441 event driven API \u0412\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441-\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043f\u0440\u043e\u043a\u0441\u0438 \u0441 event driven API Chat API (\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0447\u0430\u0442\u0430) Commands API \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 API \u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e","title":"TODO"},{"location":"ru/dev/","text":"\u0420\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430 C\u043a\u0440\u0438\u043f\u0442\u044b \u0417\u0430\u043f\u0443\u0441\u043a \u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: make format \u0417\u0430\u043f\u0443\u0441\u043a \u043b\u0438\u043d\u0442\u0435\u0440\u043e\u0432: make lint \u0417\u0430\u043f\u0443\u0441\u043a \u0442\u0435\u0441\u0442\u043e\u0432: make test \u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 C\u043d\u0430\u0447\u0430\u043b\u0430 \u043d\u0443\u0436\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0443\u0442\u0438\u043b\u0438\u0442\u044b: poetry install -E docs \u0417\u0430\u043f\u0443\u0441\u043a dev-\u0441\u0435\u0440\u0432\u0435\u0440\u0430: make docs-serve \u0421\u0431\u043e\u0440\u043a\u0430 (\u0440\u0435\u043d\u0434\u0435\u0440) \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438: make docs-build \u0421\u0431\u043e\u0440\u043a\u0430 \u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043d\u0430 github pages: make docs-deploy","title":"\u0420\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430"},{"location":"ru/dev/#_1","text":"","title":"\u0420\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430"},{"location":"ru/dev/#c","text":"\u0417\u0430\u043f\u0443\u0441\u043a \u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: make format \u0417\u0430\u043f\u0443\u0441\u043a \u043b\u0438\u043d\u0442\u0435\u0440\u043e\u0432: make lint \u0417\u0430\u043f\u0443\u0441\u043a \u0442\u0435\u0441\u0442\u043e\u0432: make test","title":"C\u043a\u0440\u0438\u043f\u0442\u044b"},{"location":"ru/dev/#_2","text":"C\u043d\u0430\u0447\u0430\u043b\u0430 \u043d\u0443\u0436\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0443\u0442\u0438\u043b\u0438\u0442\u044b: poetry install -E docs \u0417\u0430\u043f\u0443\u0441\u043a dev-\u0441\u0435\u0440\u0432\u0435\u0440\u0430: make docs-serve \u0421\u0431\u043e\u0440\u043a\u0430 (\u0440\u0435\u043d\u0434\u0435\u0440) \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438: make docs-build \u0421\u0431\u043e\u0440\u043a\u0430 \u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043d\u0430 github pages: make docs-deploy","title":"\u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439"},{"location":"ru/examples/client/","text":"examples/client.py import io import uuid from typing import Any , Callable , Coroutine import anyio from cubes import net from cubes.net import serializers _PROTOCOL = 756 _HOST = \"127.0.0.1\" _PORT = 25565 _PLAYER_NAME = \"_Smesharik_\" class NotConnectedError ( Exception ): pass class AlreadyConnectedError ( Exception ): pass class UnsuitedConnectionStatusForOperationError ( Exception ): pass class DisconnectedByServerError ( Exception ): pass class InvalidPlayerNameFromServer ( Exception ): pass class UnexpectedPacketError ( Exception ): pass class Client : _conn : net . Connection | None def __init__ ( self , host : str , port : int ) -> None : self . _host , self . _port = host , port self . _conn = None @property def connection ( self ) -> net . Connection : if self . _conn is None : raise NotConnectedError return self . _conn async def connect ( self ) -> None : if self . _conn is not None : raise AlreadyConnectedError stream = await anyio . connect_tcp ( self . _host , self . _port ) self . _conn = net . Connection ( stream ) async def disconnect ( self ) -> None : await self . _conn . close () async def login ( self , player_name : str ) -> uuid . UUID : if self . connection . status != net . ConnectionStatus . HANDSHAKE : raise UnsuitedConnectionStatusForOperationError ( self . connection . status ) handshake = io . BytesIO () serializers . VarIntSerializer ( 0x00 ) . to_buffer ( handshake ) serializers . VarIntSerializer ( _PROTOCOL ) . to_buffer ( handshake ) serializers . StringSerializer ( self . connection . remote_address [ 0 ]) serializers . UnsignedShortSerializer ( self . connection . remote_address [ 1 ]) serializers . VarIntSerializer ( net . ConnectionStatus . LOGIN ) login_start = io . BytesIO () serializers . VarIntSerializer ( 0x00 ) . to_buffer ( login_start ) serializers . StringSerializer ( player_name ) . to_buffer ( login_start ) await self . connection . send ( handshake , login_start ) self . connection . status = net . ConnectionStatus . LOGIN response = await self . connection . receive () packet_id = serializers . VarIntSerializer . from_buffer ( response ) match packet_id : case 0x00 : raise DisconnectedByServerError ( serializers . StringSerializer . from_buffer ( response ) ) case 0x02 : uuid_ = serializers . UUIDSerializer . from_buffer ( response ) player_name_from_server = serializers . StringSerializer . from_buffer ( response ) if player_name != player_name_from_server : raise InvalidPlayerNameFromServer ( player_name_from_server ) self . connection . status = net . ConnectionStatus . PLAY return uuid_ case _ : raise UnexpectedPacketError ( hex ( packet_id )) async def run ( self , handler : Callable [[ net . Connection , io . BytesIO ], Coroutine [ Any , Any , None ]], packet_receive_timeout : float = 20 , ) -> None : while True : with anyio . fail_after ( packet_receive_timeout ): packet = await self . connection . receive () await handler ( self . connection , packet ) async def __aenter__ ( self ) -> \"Client\" : await self . connect () return self async def __aexit__ ( self ): await self . disconnect () async def process_packet ( conn : net . Connection , packet : io . BytesIO ): ... async def main (): async with Client ( _HOST , _PORT ) as client : await client . login ( _PLAYER_NAME ) await client . run ( process_packet )","title":"Client"},{"location":"ru/examples/server/","text":"examples/server.py import io import json import logging import signal import anyio import anyio.abc from cubes import net from cubes.net import serializers _VERSION = \"1.17.1\" _PROTOCOL = 756 _SERVER_DESCRIPTION = \"Example server\" async def process_handshake ( conn : net . Connection , packet : io . BytesIO ): protocol = serializers . VarIntSerializer . from_buffer ( packet ) serializers . StringSerializer . from_buffer ( packet ) # host serializers . UnsignedShortSerializer . from_buffer ( packet ) # port conn . status = intention = net . ConnectionStatus ( serializers . VarIntSerializer . from_buffer ( packet ) ) if intention == net . ConnectionStatus . LOGIN and protocol != _PROTOCOL : disconnect_packet = io . BytesIO () serializers . VarIntSerializer ( 0 ) . to_buffer ( disconnect_packet ) serializers . StringSerializer ( json . dumps ( { \"translate\" : \"disconnect.genericReason\" , \"with\" : [{ \"text\" : f 'Unsupported protocol version \" { protocol } \".' }], } ) ) . to_buffer ( disconnect_packet ) await conn . send ( disconnect_packet ) await conn . close () async def process_legacy_ping ( conn : net . Connection ): await conn . close () async def process_status ( conn : net . Connection ): response = io . BytesIO () serializers . VarIntSerializer ( 0 ) . to_buffer ( response ) serializers . StringSerializer ( json . dumps ( { \"version\" : { \"name\" : _VERSION , \"protocol\" : _PROTOCOL }, \"players\" : { \"max\" : 0 , \"online\" : 0 }, \"description\" : { \"text\" : _SERVER_DESCRIPTION }, } ) ) . to_buffer ( response ) await conn . send ( response ) async def process_status_ping ( conn : net . Connection , packet : io . BytesIO ): packet . seek ( 0 ) await conn . send ( packet ) await conn . close () async def process_packet ( conn : net . Connection , packet : io . BytesIO ): packet_id = serializers . VarIntSerializer . from_buffer ( packet ) match ( conn . status , packet_id ): case ( net . ConnectionStatus . HANDSHAKE , 0x00 ): await process_handshake ( conn , packet ) case ( net . ConnectionStatus . HANDSHAKE , 0xFE ): await process_legacy_ping ( conn ) case ( net . ConnectionStatus . STATUS , 0x00 ): await process_status ( conn ) case ( net . ConnectionStatus . STATUS , 0x01 ): await process_status_ping ( conn , packet ) case _ : pass async def process_new_connection ( conn : net . Connection ): logging . info ( '\" %s : %i \" connected to server.' , * conn . remote_address ) async def process_packet_receive_timeout ( conn : net . Connection ): if conn . status == net . ConnectionStatus . LOGIN : packet = io . BytesIO () serializers . VarIntSerializer ( 0x00 ) . to_buffer ( packet ) serializers . StringSerializer ( json . dumps ({ \"translate\" : \"disconnect.timeout\" }) ) . to_buffer ( packet ) await conn . send ( packet ) await conn . close () async def process_close_connection ( conn : net . Connection , reason : Exception | None ): logging . info ( '\" %s : %i \" disconnected from server. Reason: %s .' , * conn . remote_address , repr ( reason ), ) async def sygnal_handler ( scope : anyio . CancelScope ): with anyio . open_signal_receiver ( signal . SIGINT , signal . SIGTERM ) as signals : async for _ in signals : scope . cancel () async def main (): server = net . Server ( process_new_connection , process_packet_receive_timeout , process_packet , process_close_connection , packet_receive_timeout = 5 , ) async with anyio . create_task_group () as task_group : task_group . start_soon ( sygnal_handler , task_group . cancel_scope ) task_group . start_soon ( server . run , \"127.0.0.1\" , 25560 ) if __name__ == \"__main__\" : logging . basicConfig ( level = \"DEBUG\" ) # you shoud use anyio for run server # you can use trio or asyncio as backend anyio . run ( main , backend = \"trio\" )","title":"Server"},{"location":"ru/migrations/0_2/","text":"0.1 -> 0.2 Application \u0425\u043e\u0441\u0442 \u0438 \u043f\u043e\u0440\u0442 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u0442\u0435\u043f\u0435\u0440\u044c \u043f\u0435\u0440\u0435\u0434\u0430\u044e\u0442\u0441\u044f \u0432 \u043c\u0435\u0442\u043e\u0434\u0435 Application.run \u0411\u044b\u043b\u043e C\u0442\u0430\u043b\u043e import cubes app = cubes . Application ( '127.0.0.1' , 25565 ) app . run () import cubes app = cubes . Application () app . run ( '127.0.0.1' , 25565 ) \u0412 \u0445\u0435\u043d\u0434\u043b\u0435\u0440\u044b \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0442\u0435\u043f\u0435\u0440\u044c \u043f\u0435\u0440\u0432\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043f\u0435\u0440\u0435\u0434\u0430\u0451\u0442\u0441\u044f packet_id \u0411\u044b\u043b\u043e C\u0442\u0430\u043b\u043e import cubes async def handler ( packet : cubes . ReadBuffer ): pass import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ): pass \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0445\u0435\u043d\u0434\u043b\u0435\u0440\u043e\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u0435\u0440\u044c \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442\u0441\u044f. \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0432\u0441\u0435 \u043f\u0430\u043a\u0435\u0442\u044b \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import cubes async def handler ( packet : cubes . ReadBuffer ) -> Optional [ cubes . WriteBuffer ]: \"\"\"Process Status Ping.\"\"\" return cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet . read ( 8 )) import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ) -> None : \"\"\"Process Status Ping.\"\"\" await packet . connection . send ( cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet_read ( 8 ) ) ReadBuffer \u0422\u0435\u043f\u0435\u0440\u044c \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 connection \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import cubes ... buff = cubes . ReadBuffer () import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection buff = cubes . ReadBuffer ( conn ) \u0422\u0430\u043a\u043e\u0439 \u0436\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u043e\u044f\u0432\u0438\u043b\u0441\u044f \u0438 \u0443 \u043c\u0435\u0442\u043e\u0434\u0430 from_reader \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import asyncio import cubes ... reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( reader ) import asyncio import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( conn , reader ) Connection \u041a\u043b\u0430\u0441\u0441 \u0421onnection \u0437\u0430\u043c\u0435\u043d\u0451\u043d \u043d\u0430 PlayerConnection . \u041f\u0440\u0438 \u0435\u0433\u043e \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u0438\u043d\u0441\u0442\u0430\u043d\u0441 Application \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import asyncio import cubes ... reader : asyncio . StreamReader writer : asyncio . StreamWriter conn = cubes . Connection ( reader , writer ) import asyncio import cubes import cubes.abc ... reader : asyncio . StreamReader writer : asyncio . StreamWriter app : cubes . abc . Application conn = cubes . Connection ( reader , writer , app ) \u0412 \u043c\u0435\u0442\u043e\u0434 close \u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0421loseConnection \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d \u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 reason PlayerConnection CloseConnection import cubes ... conn : cubes . PlayerConnection reason : str await conn . close ( reason ) import cubes ... reason : str raise cubes . CloseConnection ( reason ) \u0423\u0434\u0430\u043b\u0435\u043d\u044b \u043c\u0435\u0442\u043e\u0434\u044b set_current \u0438 get_current . \u0412\u043c\u0435\u0441\u0442\u043e get_current \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0438\u043d\u0441\u0442\u0430\u043d\u0441 \u0438\u0437 property connection \u0443 ReadBuffer \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import cubes ... async def handler ( packet : cubes . ReadBuffer ): conn = cubes . Connection . get_current () import cubes ... async def handler ( packet_id : int , packet : cubes . ReadBuffer ): conn = packet . connection","title":"0.1 -> 0.2"},{"location":"ru/migrations/0_2/#01-02","text":"","title":"0.1 -&gt; 0.2"},{"location":"ru/migrations/0_2/#application","text":"\u0425\u043e\u0441\u0442 \u0438 \u043f\u043e\u0440\u0442 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u0442\u0435\u043f\u0435\u0440\u044c \u043f\u0435\u0440\u0435\u0434\u0430\u044e\u0442\u0441\u044f \u0432 \u043c\u0435\u0442\u043e\u0434\u0435 Application.run \u0411\u044b\u043b\u043e C\u0442\u0430\u043b\u043e import cubes app = cubes . Application ( '127.0.0.1' , 25565 ) app . run () import cubes app = cubes . Application () app . run ( '127.0.0.1' , 25565 ) \u0412 \u0445\u0435\u043d\u0434\u043b\u0435\u0440\u044b \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0442\u0435\u043f\u0435\u0440\u044c \u043f\u0435\u0440\u0432\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043f\u0435\u0440\u0435\u0434\u0430\u0451\u0442\u0441\u044f packet_id \u0411\u044b\u043b\u043e C\u0442\u0430\u043b\u043e import cubes async def handler ( packet : cubes . ReadBuffer ): pass import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ): pass \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0445\u0435\u043d\u0434\u043b\u0435\u0440\u043e\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u0435\u0440\u044c \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442\u0441\u044f. \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0432\u0441\u0435 \u043f\u0430\u043a\u0435\u0442\u044b \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import cubes async def handler ( packet : cubes . ReadBuffer ) -> Optional [ cubes . WriteBuffer ]: \"\"\"Process Status Ping.\"\"\" return cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet . read ( 8 )) import cubes async def handler ( packet_id : int , packet : cubes . ReadBuffer ) -> None : \"\"\"Process Status Ping.\"\"\" await packet . connection . send ( cubes . WriteBuffer () . pack_varint ( 0x01 ) . write ( packet_read ( 8 ) )","title":"Application"},{"location":"ru/migrations/0_2/#readbuffer","text":"\u0422\u0435\u043f\u0435\u0440\u044c \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 connection \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import cubes ... buff = cubes . ReadBuffer () import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection buff = cubes . ReadBuffer ( conn ) \u0422\u0430\u043a\u043e\u0439 \u0436\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u043e\u044f\u0432\u0438\u043b\u0441\u044f \u0438 \u0443 \u043c\u0435\u0442\u043e\u0434\u0430 from_reader \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import asyncio import cubes ... reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( reader ) import asyncio import cubes import cubes.abc ... conn : cubes . abc . AbstractConnection reader : asyncio . StreamReader buff = await cubes . ReadBuffer . from_reader ( conn , reader )","title":"ReadBuffer"},{"location":"ru/migrations/0_2/#connection","text":"\u041a\u043b\u0430\u0441\u0441 \u0421onnection \u0437\u0430\u043c\u0435\u043d\u0451\u043d \u043d\u0430 PlayerConnection . \u041f\u0440\u0438 \u0435\u0433\u043e \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u0438\u043d\u0441\u0442\u0430\u043d\u0441 Application \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import asyncio import cubes ... reader : asyncio . StreamReader writer : asyncio . StreamWriter conn = cubes . Connection ( reader , writer ) import asyncio import cubes import cubes.abc ... reader : asyncio . StreamReader writer : asyncio . StreamWriter app : cubes . abc . Application conn = cubes . Connection ( reader , writer , app ) \u0412 \u043c\u0435\u0442\u043e\u0434 close \u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0421loseConnection \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d \u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 reason PlayerConnection CloseConnection import cubes ... conn : cubes . PlayerConnection reason : str await conn . close ( reason ) import cubes ... reason : str raise cubes . CloseConnection ( reason ) \u0423\u0434\u0430\u043b\u0435\u043d\u044b \u043c\u0435\u0442\u043e\u0434\u044b set_current \u0438 get_current . \u0412\u043c\u0435\u0441\u0442\u043e get_current \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0438\u043d\u0441\u0442\u0430\u043d\u0441 \u0438\u0437 property connection \u0443 ReadBuffer \u0411\u044b\u043b\u043e \u0421\u0442\u0430\u043b\u043e import cubes ... async def handler ( packet : cubes . ReadBuffer ): conn = cubes . Connection . get_current () import cubes ... async def handler ( packet_id : int , packet : cubes . ReadBuffer ): conn = packet . connection","title":"Connection"}]}